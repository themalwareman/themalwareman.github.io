---
title: "Translucent Kernel Memory Access from Usermode"
layout: post
date: 2023-10-20 10:50
image: 
headerImage: false
tag:
- coding
- c++
- windows
- kernel
star: false
category: blog
author: themalwareman
description: Making kernel exploits easier to work with...
---

# Setting the Scene

I was recently working on something that required us to load an unsigned driver into kernel on Windows 10 with Driver Signature Enforcement (DSE) enabled. DSE is a Windows policy that requires all drivers to have a valid signature for them to be loaded into the kernel. I’ll leave the details of why for another blog but the solution we ended up going with was exploiting our way into kernel by abusing a vulnerable driver with a valid signature. Essentially what this involves is loading an already signed driver with a vulnerability that provides us with kernel memory primitives such as read/write/allocate. The standard way for a user-mode component to communicate with a driver is via the Windows API “DeviceIoControl”, which allows user-mode to send control codes to the driver along with a memory buffer that essentially equates to calling a function in the driver where the control code is the function and the buffer is used to store the arguments. Again, I’ll leave the specifics of which driver we used and its vulnerability to another blog. Today’s focus is on attempting to clean up the access to kernel memory via, what I believe, is some rather elegant C++!

To allow us flexibility in swapping drivers out in the future (because inevitably some day the vulnerable driver’s signing certificate will be revoked and we’ll have to find a new one) we’ll wrap our kernel primitives in an interface like this:

```cpp
class IKernelPrimitiveProvider
{
public:
    virtual KernelPtr KernelAllocate(uint32_t size) = 0;
    virtual bool KernelRead(void* src, void* dst, size_t size) = 0;
    virtual bool KernelWrite(void* dst, void* src, size_t size) = 0;
};
```

Now, when using a different driver in the future we can just write a new implementation of the same interface and we should be good to go!

# The Problem

Using these KernelRead & KernelWrite primitives in their plain form is incredibly tedious. When loading our driver through this primitive we need to do all sorts of memory access such as processing relocations which require reading and writing a vast number of WORDS/DWORDS. Without any help this would look something like:

```cpp
DWORD value;
KernelRead(kernelAddress, &value, sizeof(value));
value += ...
KernelWrite(kernelAddress, &value, sizeof(value));
```

If instead we were just working with normal user mode memory that we could access directly this would instead looking something like:

```cpp
*address += ...
```

This may not seem like a colossal issue however loading a driver requires a large amount of reads and writes, and requiring 4 lines of code for every read/write operation, versus the 1 line for regular memory access, is a lot of code bloat. Cutting this back down to make the kernel memory access look more like regular old memory access would make the code vastly more readable, succinct, and greatly improves the maintainability. At this point I want to draw your attention to the KernelPtr object returned by the KernelAllocate primitive.

# The Solution

The KernelPtr object is implemented as follows:

```cpp
class KernelPtr
{
private:
    std::shared_ptr<IKernelPrimitiveProvider> _primitive;
    void* _addr = nullptr;
public:
    KernelPtr(void* addr, const std::shared_ptr<IKernelPrimitiveProvider>& primitive) : _addr(addr), _primitive(primitive) {}

    void* get()
    {
        return _addr;
    }

    KernelRef operator*()
    {
        return KernelRef(_addr, _primitive);
    }

    template<typename T>
    KernelPtr& operator+=(T value)
    {
        _addr = reinterpret_cast<byte*>(_addr) + value;
        return *this;
    }
};
```

This KernelPtr object holds a pointer to a kernel memory address but it also needs access to the kernel primitive provider if it wants to be used to modify any kernel memory. This is done by giving it a shared_ptr to the interface when its constructed that it can save off for later use.

The bit to focus on here is the overloaded dereference operator: `KernelRef operator*()`. This overloaded operator returns us a KernelRef object. (I know its getting a bit convoluted but stay with me here). This KernelRef object is intended to act as a reference (hence the name) to some kernel memory address. The implementation looks something like:

```cpp
class KernelRef
{
private:
    std::shared_ptr<IKernelPrimitiveProvider> _primitive;
    void* _addr = nullptr;
public:
    KernelRef(void* addr, const std::shared_ptr<IKernelPrimitiveProvider>& primitive) : _addr(addr), _primitive(primitive) {}

    template<typename T>
    KernelRef& operator=(T value)
    {
        _primitive->KernelWrite(_addr, &value, sizeof(T));
        return *this;
    }

    template<typename T>
    operator T()
    {
        T tmp;

        _primitive->KernelRead(_addr, &tmp, sizeof(T));

        return tmp;
    }
};
```

Again because we intend to use this to modify kernel memory both the address and primitive provider are forwarded into its constructor. Let’s start by looking at the templated conversion operator:

```cpp
template<typename T>
operator T()
{
  T tmp;
  _primitive->KernelRead(_addr, &tmp, sizeof(T));
  return tmp;
}
```

This templated conversion operator allows you to convert a KernelRef object to the type you ask for (assuming the template instantiation is valid C++). So if we have something like:

```cpp
KernelPtr ptr = ...
...
DWORD valueInKernel = *ptr;
```

It will attempt to use this template to convert the KernelRef to a DWORD. Which in this case will create a DWORD on the stack, read the bytes directly from kernel into it, then return it as the conversion. We need to be careful to only use this for fundamental types because attempting to convert to a compound type like a class would give you garbage but for scalar types like ints, uints etc or reading pointers its perfectly safe! To disable this method for those types we could just add some SFINAE to the template to disable it in those cases making this a bit safer. 

This is starting to look like much more readable and idiomatic already! But we won’t stop here!

Okay, so reading somewhat transparently from kernel works, but what about writing? For this we have our templated assignment operator! I use the word assignment lightly because we don't actually modify our KernelRef object in anyway.…

```cpp
template<typename T>
KernelRef& operator=(T value)
{
	_primitive->KernelWrite(_addr, &value, sizeof(T));
	return *this;
}
```

This templated assignment operator allows us to assign from an arbitrary type so we can have something like:

```cpp
DWORD value = ...
*ptr = value;
```

This gives our assignment operator the chance to run which instead of trying to modify the KernelRef object itself will just write the contents of the assigned type directly to kernel memory using the primitive provider.

Putting this all together we get **almost** transparent (okay, we’ll call it translucent) access to kernel memory from user mode code:

```cpp
IKernelPrimitiveProvider* provider = new PrimitiveImplementation();
KernelPtr ptr(pKernelMemory, provider);
// Writing to kernel
*ptr = value;
// Reading from kernel
DWORD valueWritten = *ptr;
```

This makes the code that reads to and writes from kernel much more readable and easy to follow!

But we can go further! You might have noticed the other function we gave to the KernelPtr object:

```cpp
template<typename T>
KernelPtr& operator+=(T value)
{
    _addr = reinterpret_cast<byte*>(_addr) + value;
    return *this;
}
```

This templated addition assignment operator allows us to perform pointer arithmetic on the KernelPtr object. Say we need to write an array of DWORDs into kernel we could now have:

```cpp
KernelPtr ptr = ...
std::vector<DWORD> dataArray = ...

for(int i = 0; i < dataArray.size(); i++)
{
	*ptr = dataArray[i];
	ptr += sizeof(DWORD);
}
```

Pretty handy right! We could also implement subtraction assignment so that we can step backwards too.  But we can go further! This platform of objects gives us the ability to add all sorts of helpful functionaility to make working with kernel memory easier. Say for example we needed to read a string from kernel, we can add a conversion operator to the KernelRef object like so:

```cpp
operator std::string()
{
    char stringBuffer[MAX_PATH + 1]{};
    _primitive->KernelRead(_addr, &stringBuffer[0], sizeof(stringBuffer) - sizeof(char));
    // This constructor will chop off everything from the null terminator onwards
    return std::string(&stringBuffer[0]);
}
```

Now this code is a bit rough, we assume that the string is fewer than max_path characters. To do this properly we should scan forward for the null terminator and calculate the length of the string we need to read but this is just to illustrate the point. Now we can read a string from kernel like this:

```cpp
KernelPtr ptr = ...
std::string kernelString = *ptr;
```

We could go further yet again but we’ll stop here now for the sake of this blog length, thank you to those who have made it this far, appreciate that this is more of an essay than a blog at this point!

With our translucent kernel memory access sorted, next time we’ll walk through how you load a driver using a kernel read/write primitive, and more importantly, how you get execution in the kernel!