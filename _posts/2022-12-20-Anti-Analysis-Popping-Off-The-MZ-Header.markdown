---
title: "Anti-Analysis: Popping off the MZ Header"
layout: post
date: 2022-12-20 18:05
image: 
headerImage: false
tag:
- pe
- anti-analysis
- reverse engineering
star: false
category: blog
author: themalwareman
description: Misleading the reverse engineer...
---

# Introduction

During the normal course of business, a colleague of mine came across an interesting upload to VirusTotal titled "Evasion.exe". Itâ€™s rather unusual for someone to make our jobs quite so easy but Iâ€™ll take a quick win when itâ€™s on offer! After looking for similarly named binaries it became clear that this user was testing something (presumably an evasion technique). There were over 5 binaries with varying numbers of Anti-Virus detections so colour me intrigued.

<aside>
ðŸ’¡ N.B. This write up is based on 0b2a9d28d773dc94dc814222b705190aadc4cdf74d3a96e1d447c8c4a7625289
</aside>

### Debugger Check

After downloading the binary in question, I loaded it into my analysis environment and started poking around. Immediately we see a common malware tactic of checking for a debugger:

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/DebuggerCheck.png)

1. `mov rax, gs:60h`
    - In x64 the gs (or Global Segment) register holds the address of a structure called the Thread Information Block (TIB). At offset `60h` into the TIB is a pointer to the Process Environment Block (PEB). So this first instruction is simply getting ahold of the PEB.
2. `cmp dword_ptr [rax+0BCh], 70h`
    - This instruction is comparing the value at offset `0BCh` in the PEB, which is the NtGlobalFlag with the value `70h`. The NtGlobalFlag value as you would imagine contains flags. More specifically when debugging an application, the following flags are usually set:

| Flag | Value |
| --- | --- |
| FLG_HEAP_ENABLE_TAIL_CHECK | 0x10 |
| FLG_HEAP_ENABLE_FREE_CHECK | 0x20 |
| FLG_HEAP_VALIDATE_PARAMETERS | 0x40 |
| Total | 0x70 |

So the comparison against `70h` is just checking to see if the application is being debugged. If it is, then it jumps to the end of the function and the application exits without doing anything.

If you want to debug malware with this debugger check, the simplest solution is just to patch the assembly code to check for a value other than `70h`. Either way, nothing particularly new or interesting thus far.

### Import Hashing

Stepping further into the binary the next thing we see is some good old fashioned function lookup via hash. "Whatâ€™s that?" I hear you say! Rather than calling the GetProcAddress function to dynamically resolve an API the malware walks the export directory of a specific dll manually, and rather than hold onto the exact name of the function such as "VirtualAlloc" (an API commonly used to allocate more executable memory) it uses a pre-calculated string hash. It then walks through the names of all the exported functions and hashes them one-by-one, so it can then compare the newly generated hash with its precalculated one. Eventually the two hashes match and itâ€™s found the function it was looking for! Now this doesnâ€™t stop a researcher figuring out which function is being resolved but it certainly makes it more difficult and time-consuming.
For completeness letâ€™s take a quick look at how it does this. Right after the debugger check we come across the following code. It starts off with 2 calls to LoadLibraryW to load Kernel32.dll and User32.dll respectively which are then shortly followed by 3 repeated calls to sub_140001000. Itâ€™s worth noting that for the first call:

- rcx = Base address of kernel32
- rdx = 3A9FB57h

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/ImportHashing.png)

Now letâ€™s dive into the resolution function sub_140001000!

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/ImportHashingResolve.png)

Iâ€™ve added comments in the IDA screenshot for clarity, but we can see that it starts off by looking up `rcx+3Ch`. All PEs (in this case kernel32.dll) start with a DOS Header, this is a relic from ancient times when everyone used to run MS-DOS but for backward compatibility it has been kept. The solution? Put the offset to the new PE header after the DOS stub at, you guessed it, offset `3Ch`. In the DOS Header struct definition this value is defined as `LONG   e_lfanew;` where lfanew stands for long file address new, or more simply, the new PE header.

Once it has the new PE header it then adds a further `88h = 136` to that address, in x64 these 136 bytes account for:
4 bytes for the PE signature + 20 bytes of COFF File Header + 112 bytes of Optional Header
Which brings us to the Data Directories. The first data directory is the export directory and the first value in the data directory structure is the directory RVA (relative virtual address) so the instruction:

`mov r8d, [rax+rcx+88h]`

Has resolved the VA (virtual address) of kernel32.dllâ€™s export directory. Note the RVA became a VA when it was added to the image base (rcx). You can see at this point it loads a few more addresses from the Export Directory namely the AddressOfFunctions, AddressOfNames & AddressOfNameOrdinals.

Time for a quick introduction on how exported functions are found! Firstly, weâ€™ll borrow this handy-dandy image thatâ€™s been floating around the internet for a while:

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/Exports.png)

When we want to find an exported function by name we must first walk the AddressOfNames table. This table is an array of RVAs to strings containing the name of the exported function. Given that functions can also be exported by ordinal this array of name pointers may be much shorter than the AddressOfFunctions array as we may have fewer names than we do exported functions. The solution is to add a second parallel array called the AddressOfNameOrdinals array which tells you which exported function the name corresponds to. Following an example here say we are looking for the exported function named by name4, when we match with it we look for the corresponding ordinal in the AddressOfNameOrdinals array which in this case returns us the value 8. We then know that the function address that matches name4 is the 8th address in the AddressOfFunctions array. Simple right? (For godâ€™s sake Microsoftâ€¦) Anyhow, the function therefore requires all 3 tables to resolve the exported function itâ€™s looking for!

However, at this point what weâ€™re more interested in is the hashing function so that we can figure out what functions the binary is looking for. In most cases itâ€™s simpler to just follow along with a debugger and check what function pointer is resolved but thatâ€™s not always possible. So, for the purposes of this article (come on, youâ€™re already too committed at this point) weâ€™ll walk through the more complicated solution of re-creating the function hashing method. Letâ€™s take a quick look at the disassembly:

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/HashingFunction.png)

The assembly is a bit misleading, probably intentionally so but weâ€™ll walk through it together:

1. r11 contains the AddressOfNames pointer so `mov edx, [r11]` is loading the first name pointer.
2. rax is filled with all Fs which equates to -1
3. rbx, which contains the dll base address is added to rdx to convert the first name pointer from an RVA to a VA
4. r8 is calculated as -1 + 70 = 69
5. Next we have a loop that increments rax by 1 to give 0 and then uses rax as an index in the loop to walk through the string looking for a null terminator (`cmp byte ptr[rdx+rax], 0`)
6. Now we have the number of characters in rax
7. r9 is zeroed and they check rax (i.e. the number of characters) is not 0
8. The last loop is the rudimentary hashing algorithm that equates to:
    - Load the next character into ecx
    - r8 = r8 + r8 \* 2 = r8 \* 3
    - r9 (the loop counter) is incremented
    - rdx (the string indexer) is incremented
    - The character value in ecx is added to r8
    - The loop checks if its time to exit

If we distil this logic down into a function we can re-create this hashing function as:

```c++
int hash(const wchar_t* pName)
{
    int ret = 69;

    do
    {
        int tmp = *pName;
        ret = 3*ret + tmp;
        pName++;
    } while(*pName);

    return ret;
}
```

Luckily I was able to debug the sample and was therefore able to verify that the first hash `3A9FB57h` equated to VirtualAlloc and correlate that with the hashing function we re-created:

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/HashingFunctionRecreated.png)

As you can see if we pass "VirtualAlloc" into our hashing function we get the same hash value `(3a9fb57)` spat out! Success!! The painful thing about having hashes to resolve though sadly is that we need to calculate name hashes for every function exported by kernel32.dll (which is over 1500) and then search that list for the hash. We then have to do this for the function itâ€™s searching for in user32.dll as well. Luckily I havenâ€™t left this as an exercise for the reader, and the results are:

In kernel32.dll

- `3A9FB57h` = VirtualAlloc
- `AEA2F1Fh` = RtlMoveMemory

In shell32.dll

- `A7DAE2Ch` = EnumDesktopsA

Not quite the set of functions I was expecting but then again, Iâ€™m only writing about this binary because itâ€™s interesting so what do you expect!

### The Execution Chain

Okay, so weâ€™ve checked for a debugger, resolved a few APIs, now what? As always letâ€™s follow the disassembly:

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/ExecutionChain.png)

After resolving the APIs, the binary starts off by allocating some virtual memory using VirtualAlloc. If we examine the registers, we see:

- rcx = `0h`
- rdx = `7501h`
- r8 = `1000h`
- r9 = `40h`

For those of you that know your x64 calling convention these registers are the first 4 parameters (and VirtualAlloc only takes 4). Correlating this with the API docs this translates to lpAddress being NULL meaning the binary doesnâ€™t care where this memory is allocated. The size of the allocation, dwSize, is `7501h` = 29,953 bytes. The allocation type, flAllocationType, is `1000h` = MEM_COMMIT which means they want the memory to be accessible right away, and lastly flProtect, the memory protections, are set as `40h` = PAGE_EXECUTE_READWRITE or more commonly, RWX.

Next, we see the rather humorous string "meowmeowmeowmeow" being loaded into r8 which is subsequently used as an XOR key to decode `7500h` bytes of data (hence the allocation size) from the .data section, which is referenced here as unk_140003060 by IDA. After the decoding loop we have a call to RtlMoveMemory (essentially identical to memmove) which copies the decoded data into the newly allocated RWX memory. If we then dump this memory we find a second PE! But thatâ€™s not the good bit just yet!!

We get a call to GetProcessWindowStation which returns a handle required for the next call to EnumDesktopsA. Hereâ€™s where it getâ€™s interestingâ€¦ If we take a look at the registers we get:

- rcx = Handle from GetProcessWindowStation
- rdx = RWX memory
- r8 = NULL

Why do they call EnumDesktopsA? Is it something Desktop related? Not in the slightest!! EnumDesktopA enumerates all desktops associated with the specified window station of the calling process. It passes the name of each desktop, in turn, to an application-defined callback. Here the binary has passed its newly allocated RWX memory as the application-defined callback. Itâ€™s a redirection to shellcode!!

So, whatâ€™s the big deal? Well, usually when malware allocates some shellcode it calls into the shellcode directly, either via a call or jump instruction. This provides a direct link from the shellcode back to the malware when doing things like stack tracing (albeit this is difficult on x64), but what this sample does is call EnumDesktopsA which in turn will pass through Windowâ€™s code to call its shellcode for it! (I originally thought it might use another thread but from my own testing it uses the caller's thread to execute the callback). Itâ€™s a clever way of trying to disassociate the shellcode from the offending binary. In fact, this even opens the doors for calling a very specific set of APIs indirectly. Specifically, any API that requires 2 or fewer parameters where either the first parameter is a string or type confusion on the string is enough control for the API. This is due to the callback definition:

```c++
typedef BOOL (CALLBACK* NAMEENUMPROCA)(LPSTR, LPARAM);
```

So what would be an example? (PoC or GTFO as they say)

Letâ€™s use LoadLibraryA! LoadLibraryAâ€™s prototype is:

```c++
HMODULE LoadLibraryA([in] LPCSTR lpLibFileName);
```

So how do we get control of the first parameter? Isnâ€™t that the name of the Desktop? Why, yes, it is. The solution is to just create our own desktop using CreateDesktopA. If we create a desktop named "winhttp.dll" for example, if we call EnumDesktopsA passing LoadLibraryA as our callback function then LoadLibraryA will be called for each desktop name. This isnâ€™t an issue for the other desktops as LoadLibraryA will simply fail but when itâ€™s called for the desktop named "winhttp.dll" weâ€™ll get a dll load!

Now, this PoC sort of defeats the point a little bit given that we obviously resolve the API LoadLibraryA but we could, with a little more effort, walk the PEB to find kernel32.dll and walk itâ€™s exports to find LoadLibraryA by hand. However, letâ€™s look at the PoC:

```c++
int main()
{
    FARPROC pLoadLibrary = GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");

    HDESK hDektop = CreateDesktopA("winhttp.dll", NULL, NULL, 0, DESKTOP_CREATEWINDOW, NULL);

    HWINSTA handle = GetProcessWindowStation();

    EnumDesktopsA(handle, reinterpret_cast<DESKTOPENUMPROCA>(pLoadLibrary), NULL);
}
```

First we resolve the address of LoadLibraryA as we need to pass it as the callback function to EnumDesktopsA. Next we create a desktop with the name of the dll we want to load, in this case "winhttp.dll". Next we call GetProcessWindowStation() to get a handle required for the call to EnumDesktopsA. Finally we call EnumDesktopsA with LoadLibraryA as the callback and voila! Winhttp.dll getâ€™s loaded on our behalf!

Just for proof, before the call to EnumDesktopsA:

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/EnumDesktopsABefore.png)

And after:

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/EnumDesktopsAAfter.png)

Pretty cool! However, I digress, thereâ€™s more to this story!

### Popping Off The MZ Header

Unpacking some shellcode isnâ€™t particularly noteworthy, although the EnumDesktopsA shellcode redirect is a cool trick. However, the real point of this blog is what comes next. As I mentioned a second PE was loaded into the new RWX memory region, but it wasnâ€™t loaded exactly, it was RtlMoveMemoryâ€™d!

What does this mean? Well, PEs need to be "mapped" into virtual memory, they contain sections which are supposed to be aligned to page boundaries when loaded into memory. Without this step all of the addressing within the code is incorrect. So how exactly is this second PE going to run? It isnâ€™t. Or at least not in the way youâ€™d expect.

The shellcode redirect actually points execution straight at the DOS header! The DOS header contains metadata, not code! Or does it? The DOS header we touched on earlier actually starts with 2 magic bytes namely `0x4D` and `0x5A`. When translated to ASCII this becomes "MZ" which is why the DOS header is also sometimes referred to as the MZ header. This magic is whatâ€™s used to identify a PE. Now, if you remember above, this header is a relic of the old times and the only field that is relevant is the e_lfanew value at offset `0x3C` that points to the new header. This leaves a little opportunity to hide something in the DOS header. If we compare the DOS header of this second PE to a normal PE you might notice something:

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/DosHeadersCompared.png)

Here, Iâ€™ve compared it to kernel32.dll, and you can see that after the MZ header the bytes differ! The author has cleverly placed shellcode in the MZ header. If you simply dumped the memory region (or retrieved it from a sandbox) and loaded it into an analysis software like IDA. This PE would be treated as a normal PE because the MZ magic is still present as is the e_lfanew value at `0xC3`. In fact IDA happily loads this PE because nobody pays any attention to the DOS header anymore. And hereâ€™s where the anti-analysis comes in, the binary doesnâ€™t execute at all, so youâ€™d be looking in the wrong place!

As discussed the shellcode redirect points directly at the MZ header, and although this is actually supposed to magic bytes with no real meaning, if you attempt to interpret `0x4D 0x5A` as shellcode you get legitimate instructions! Itâ€™s the machine code for `pop r10`!!

Whaaaaaaaaat! I know! If we deconstruct this second PE header as shellcode we get:

![](/assets/images/posts/2022-12-20-Anti-Analysis-Popping-Off-The-MZ-Header/DisassembledHeader.png)

As I said the MZ header magic equates to `pop r10` so this shellcode first corrects the stack by pushing r10 back onto the stack. Next it uses a common shellcode trick for figuring out where in memory it is. It uses a call instruction `call $+5` which calls into the very next instruction (the call instruction is 5 bytes of assembly). This causes a return address to be pushed onto the stack. `pop rcx` pops the return address off the stack into rcx. Next 9 is subtracted, which is the number of bytes up to and including the call instruction, this is calculating the start of the shellcode memory region. It then moves this value into rax and adds `7000h`. It turns out this is the location of some additional shellcode located beyond the end of the PE, often referred to as overlay data. Finally, it calls into the next block of shellcode.

Given that this second block of shellcode is overlay data, IDA wonâ€™t even try to analyze it as part of the PE, so if you missed this funky trick with the MZ header youâ€™d be reverse engineering a red herring! In summary this binary uses not only a clever way of diving into the shellcode via a seemingly unrelated Windows API, but it also cleverly tries to hide the real code by abusing the fact that the magic bytes in the MZ header can unintuitively be interpreted as legitimate shellcode!

Pretty cool!