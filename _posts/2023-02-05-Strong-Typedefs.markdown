---
title: "Strong Typedefs: When typdef just doesn't cut it..."
layout: post
date: 2023-02-05 12:52
image: 
headerImage: false
tag:
- coding
- c++
- windows
star: false
category: blog
author: themalwareman
description: Creating types for fun and profit...
---

# Strong Typedefs

I don't know if anyone is a C++ lover but I came across a beautiful concept today called "Strong typedefs" that someone (seemingly at boost) came up with. One of the projects I've been working on lately required some generic templates for printing out function arguments. Now, I know what you're thinking, "Why don't you just use a library?". Well, that's kind of a long answer so I'll leave it for another time. Without getting bogged down in the why let's focus on the what. String pointers.

As you'd expect with printing out function arguments, printing a string pointer isn't particularly useful, I also want to print the string pointed to by the pointer. In the templated code this is perfectly fine, I can provide a print function overload for string pointers that prints the pointer and then the string. This would be different to a normal pointer or handle where I just print the memory address or handle value. For example if a `VOID*` is passed in a Windows API as a parameter called lpAddress my trace for that argument would look like:

`lpAddress = 0x85178323`

However, if its a string pointer called lpProcName like in the API GetProcAddress, I want my trace to look like this:

`lpProcName = 0x6567632 (VirtualAlloc)`

Where "VirtualAlloc" is the string pointed to by `0x6567632`. In C++ this is perfectly do-able via SFINAE or function overloads. Taking function overloads as the approach we can have:

```c++
void trace(void* arg)

void trace(const char* arg)
```

which are totally separate functions that the compiler/linker can differentiate by their parameters.

The issue comes with some Windows APIs where the parameter is a string pointer but it's an [in, out] parameter and the buffer pointed to by the string pointer may be uninitialised. For example in the Window's API GetUserName, a string pointer is passed as an [in,out] param where the API writes the username into the user provided buffer. Given the function call tracing is done on the way in (because we want to see the in values mainly, although im working on a way to try and show out values too), we have an issue. If I try to blindly print the string in the buffer, which is often uninitialised as the caller is passing it to the API to fill out, it might be full of garbage that can cause an invalid memory access. This can happen as the string printing function might go beyond the end of the buffer because it'll walk through memory until it hits a null terminator. If it doesn't find one however, then it could continue to walk through to an invalid memory address. So in this case I want a trace function for a string pointer that doesn't try to print the string.

You may think that we can just use a typedef to give a second type name to a `const char *` and use the same function overload approach as above. The issue in C++ though is that normal typedefs are just aliases for types so:

```c++
void trace(const char* arg)

typdef const char* unprintable_string;

void trace(unprintable_string arg)
```

are the same function, I've renamed a type, not made a brand new one. This is where strong typedefs come in. Some genius person came up with the concept of a strong typedef where you create a new type by creating a new struct that holds the type. Then in C++ you can provide a conversion operator that allows the struct to be convertible to the type it contains. So now we can have:

```c++
void trace(const char* arg)

struct unprintable_string
{
    const char* arg;

    // This makes unprintable_string convertible to a const char*
    operator const char* {return arg};
}
```

then in the GetUserName function trace I can wrap the string pointer as an `unprintable _string` before it goes into the template code. This way I can now have a print overload for my new type

```c++
void(unprintable_string arg)
```

but also when I pass this parameter on in the template code to the Windows API it'll convert perfectly back to a `const char *` at the call site via an implicit conversion! Note that to allow the implicit conversion we don't need to add anything, we just need to avoid marking the conversion operator in our structure as explicit.

### Aside on 'explicit'

Sometimes conversion operators or constructors are marked explicit to avoid confusing conversions that likely weren't intended by the coder. For example when you construct a std::vector to hold some integers, you may already know that it needs to hold 10 integers. In this scenario you'd want to use the vector constructor that takes a count.

`std::vector<int> myVec(3); // Creates a 3-element vector holding {0, 0, 0}`

This constructor is marked explicit though (using a slightly old C++11 definition for simplicity):

`explicit vector( size_type count );`

The reason for this is if a coder calls a function and passes an integer value as a parameter, they probably aren't expecting an implicit conversion to a vector. A hopefully more obvious example is the following:

```c++

class Circle
{
private:
  int m_radius;

public:
  // Single parameter constructor can be used for implicit conversion
  Circle (int radius) : m_radius (radius) {}

  int GetRadius () { return m_radius; }
};

void Draw (Circle circle)
{
  int i = circle.GetRadius();
  ...
}

int main ()
{
    Draw(42);
}
```

If you imagine this code split across multiple files it might be very easy to think `Draw(42)` is intended to draw the number 42 as a text label say. It's incredibly unlikly the coder intended for the number 42 to be converted into a Circle object. If they did, then this is also rather hard to follow code. If however the constructor was marked as explicit:

`explicit Circle (int radius) : m_radius (radius) {}`

Then `Draw(42)` becomes invalid code as there is no possible implicit conversion from an integer to a Circle. To achieve the same result it would now be `Draw(Circle(42))` which is a lot more obvious.

(If you want to know more about implicit conversions checkout [this](https://en.cppreference.com/w/cpp/language/implicit_conversion) page from Cpp Reference).

### Jumping back to the issue at hand...

Strong typedefs now enable me to implement different print functions for the same arguments!! If you have an API that takes a `DWORD` value for flags you could use a strong typedef to give that DWORD its own type and implement a print function that can print out the name of the flags passed via that `DWORD`. For example in a CreateFileA API trace `dwDesiredAccess = C0000000` isn't particularly useful but `dwDesiredAccess = (GENERIC_READ | GENERIC_WRITE)` is!

Now although I could use this method for `DWORD` types I actually use an easier method. Enum Classes!! An enum class in C++ can inherit from a base type like `int` (or `DWORD`) so you can guarantee the enum is the correct size, but its also a new type so we can provide a print overload! This is how we print out the flags for APIs like CreateFile as demonstrated above. One of the reasons for this is that using another strong typedef and passing that new type into a template ends up driving more template generation and bloating the size of the binary.